<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>构造函数中重复的问题</title>
</head>
<body>
    <!-- 
        任务：创建一个 Person 构造函数，以创建对象. 要求有 name，age, gender 和 sayHello
     -->
    <!-- <script>
        function Person(name, age, gender) {
            this.name = name;
            this.age = age;
            this.gender = gender;
            this.sayHello = function () {
                console.log("你好，" + this.name);
            }
        }

        var p1 = new Person("张三", 18, "男");
        var p2 = new Person("李四", 19, "女");

        // 1.在代码中出现函数与对象，如果重复执行，会创建多个副本
        // 2.那么每一个对象都含有一个独立的，不同的，但是功能逻辑一样的函数，比如：`{}=={}`
        // 3.在代码中方法就会消耗性能，最典型的资源就是内存。
        // 4.这里最好的办法就是将函数体放在构造函数之外，那么在构造函数中只需要引用该函数即可。
        console.log(p1.sayHello == p2.sayHello);
    </script> -->

    <!-- 改良 
        1.传统的构造方法的定义方式会影响性能，容易造成多个对象有多个方法副本，应该将方法单独抽取出来，让所有的对象共享该方法。
    -->
    <!-- <script>
        function sayHello(){
            console.log('.....')
         }
        function Person(name, age, gender) {
            this.name = name;
            this.age = age;
            this.gender = gender;
            this.sayHello = sayHello;
        }

        var p1 = new Person("张三", 18, "男");
        var p2 = new Person("李四", 19, "女");

        console.log(p1.sayHello == p2.sayHello); 
    </script> -->
    <!-- 
        2. 可以考虑将方法全部放到外面但是有安全隐患
            * 在开发中会引入各种框架或库，自定义的成员越多，出现命名冲突的几率越大。
            * 可能在开发中会有多个构造函数，每一个构造函数应该有多个方法，那么就会变得不容易维护。
            * 解决办法就是外面的函数如果不占用名字（避免冲突），而且在函数旗下（便于管理）就好了。
        
        3. 任意一个对象都会默认连接到它的原型中
            * 创建一个函数，会附带的创建一个神秘对象，该神秘对象使用 “函数.prototype” 引用。称它为函数的 “原型属性”。
            * 每一个由该函数作为构造函数创建的对象，都会默认的连接到该神秘对象上。
            * 在该对象访问某一个方法或属性的时候，如果该对象中没有，就会到这个神秘对象中去查找。 
            * 由同一个构造函数创建出来众多对象，共享这个神秘对象。
            * 只要将需要共享的东西、重复占用内存的东西、放到这个神秘对象（函数.prototype）中，那么众多对象就可以共享数据了。
     -->

     <!-- 优化 -->
    <script>
        function Person(name, age, gender) {
            this.name = name;
            this.age = age;
            this.gender = gender;
        }

        Person.prototype.sayHello = function() {
            console.log(".....")
        }

        var p1 = new Person("张三", 18, "男");
        var p2 = new Person("李四", 19, "女");

        console.log(p1.sayHello == p2.sayHello); 
    </script>

</body>
</html>