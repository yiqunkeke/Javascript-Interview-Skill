1. 何时使用"===", 何时使用"==", 为什么？ 两者有什么区别？

    考点： 强制类型转换

    知识点： 什么情况下会发生强制类型转换？ 以下4种情况会发生强制类型转换

            1. 与字符串拼接

                let a = 100 + '10'  //  '10010'
                let b = 100 + 10  // 110
                let c = '42' * 1  // 42

                第一个表达式中， + 号后面的 10 是字符串'10', 则默认为会把 + 号前面的 100 转换成字符串'100'
                这就是发生了强制类型转换。

                第二个表达式，是正常的+运算

                第三个表达式中，将字符串'42'强制转换成数字42，所以结果是数字类型的42


            2. 使用 == 双等运算符

                100 == '100'  // true

                上面表达式中，会把 == 前面的数字 100 强制转换为字符串 '100', 然后与 == 后面的 '100' 做比较，
                所以，使用 == 时，会发生强制类型转换。


                0 == ''  // true

                上面表达式中，会把 == 前面的数字 0 以及 == 后面的字符串 '', 分别都转换为布尔类型的 false,
                所以 两者相等，结果为 true


                null == undefined  // true

                同理 0 == '', 会把 null 和 undefined 都转换为布尔类型的 false, 两者相等，结果为 true 
				
				
				总结（tips）： 空字符串、0、NaN、null, undefined 都会被转为 false


            3. if() 语句

                let a = true
                if(a) {
                    ...
                }

                上面语句中，是正常的情况


                let b = 100
                if(b) {
                    ...
                }

                上面语句中，if()语句会把变量 b 强制转换为布尔类型的 true，然后执行 if 代码块中的程序

                let c = ''
                if(c) {
                    ...
                }

                上面语句中，if()语句会把变量 c 强制转换为布尔类型的 false, 然后不执行 if 


            4. 逻辑运算

                100 && 0  // false

                上面表达式中，会把 100 和 0 分别强制转换为布尔类型的 true 和 false , 所以，与运算的结果为 false

解答：
        除了 object.a 使用 ==, 其它都用 ===

        因为这是 jQuery 源码的推荐写法

        object.a == null 是 object.a === null || object.a === undefined 的简写。
    
	
	
	注意(tips)：
		对于 number 类型的浮点数，
		
		永远不要判断两个浮点数是否相等。
		
		如果非要判断浮点数，建议都乘以10或者100，转为整数之后再进行判断。
		
		例如：
			var result = 0.1 + 0.2 // 结果不是0.3，而是0.30000000000000004
			
			console.log(0.07*100) // 结果是 7.000000000000001
			
		因为计算机在处理浮点数时是模拟，产生结果可能会有差错。	
		
		
		
	
                







    

        

