闭包：归根结底还是考查对作用域和作用域链的问题

什么情况下会产生闭包：

    1. 函数作为另一个函数的返回值时

        function f1 () {
            var a = 100
            return function(){
                console.log(a)   // 自由变量 a的作用域链，在定义时已经创建： return后面的返回值函数 ---> 函数：f1(){} ---> 全局
            }
        }

        let f = f1()   // 定义变量 f, 来接收 f1()函数的返回值，因为f1()函数的返回值是另一个函数（我们暂且叫做“返回值函数”），所以变量 f，就是返回值函数
        var a = 200
        f()  // 100   // 执行 f(), 就会去执行 f1()函数中的返回值函数（即return语句后面的函数） // 自由变量a 值是 100


    2. 函数作为另一个函数的参数时

        function f1() {
            var a = 100 
            return function(){
                console.log(a)  // 分析自由变量a的作用域链即可：返回值函数 ---> 函数：f1(){} ---> 全局作用域
            }
        }

        let f = f1()
        
        function f2(fn){
            var a = 200
            fn() // 虽然 f1 的返回值函数 f , 在函数 f2 中被调用 ，但是自由变量a的作用域链，在定义时，就已经创建。调用时，只需要按照作用域链去寻找即可
        }

        f2(f)

闭包的作用： 
        从上面第二种情况（函数作为另一个函数的参数时），
        可以看出，闭包使得一个函数有权访问另一个函数作用域的变量
        能够读取其它函数内部变量

正常的函数执行完毕后，里面声明的变量会被垃圾回收处理掉，
但是闭包可以让作用域里面的变量，在函数执行完之后依旧保持没有被垃圾回收处理掉

闭包缺陷：
        通过上边的例子也发现, 闭包会导致内存占用过高,因为变量都没有释放内存



        



