### 完成事件
* 单独的Promise展示了未来值的特性。
* 也可以从另一个角度看待Promise决议：一种在异步任务中作为两个或更多步骤的**流程控制**机制。

> 假定要调用一个foo(..)执行某个任务，我们不知道也不关心它的任何细节。这个函数可能立即完成任务，也可能需要一段时间才能完成。

> 我们只需要知道 foo(..) 什么时候结束，这样就可以进行下一个任务。

> 换句话说，我们要想通过某种方式在 foo(..)完成的时候得到通知，以便可以继续下一步。

* 定义：对foo(..)发出的一个**完成事件（completion event 或 continuation 事件）**的侦听。


### 关注点分离 和 反控制反转
* 使用回调的话，通知就是任务(foo(..))调用的回调。
* 使用Promise，把关系反转过来：侦听foo(..)的事件，然后在得到通知的时候，根据情况继续。

* 伪代码：
```
    foo(x) {
        // 开始做点可能耗时的工作
    }

    foo(42);

    on(foo "completion") {
        // 可以进行下一步了
    }

    on(foo "error") {
        // 啊，foo(..)中出错了
    }
```
> 我们调用foo(..)，然后建立了两个事件侦听器，一个用于"completion"，一个用于"error"-----foo(..)调用的两个可能的结果

> 从本质上讲，foo(..)并不需要了解调用代码订阅了这些事件，这样就很好的实现了**关注点分离**。

* js中更自然的代码：
```
    function foo(x) {
        // 开始做点可能耗时的工作

        // 构造一个listener事件通知处理对象来返回
        return listener;
    }

    var evt = foo(42);

    evt.on("completion", function(){
        // 可以进行下一步了
    })

    evt.on("failure", function(err){
        // 啊，foo(..)中出错了
    })

```
> foo(..)显式创建并返回了一个事件订阅对象，调用代码得到这个对象，并在其上注册了两个事件处理函数。

> 相对于面向回调的代码，这里的反转是显而易见的，而且这也是有意为之。这里没有把回调传给foo(..)，而是返回一个名有evt的事件注册对象，由它来接受回调。

> 回调本身就是一种控制反转，所以对回调模式的反转实际上是对反转的反转，或者称为**反控制反转**-----把控制返还给调用代码。这也是我们最开始想要的效果。

### 对控制反转的恢复实现了更好的关注点分离
* 可以把这个事件侦听对象提供给代码中多个独立的部分；在foo(..)完成的时候，它们都可以独立地得到通知，以执行下一步：
```
    var evt = foo(42)

    // 让 bar(..)侦听foo(..)的完成 
    bar(evt);

    // 并且让 baz(..)侦听foo(..)的完成 
    baz(evt);
```
> 其中，bar(..)和baz(..)不需要牵扯到foo(..)的调用细节。
> 类似地，foo(..)不需要知道或关注bar(..)和baz(..)是否对存在，或者是否等待foo(..)的完成通知
> 这样，对控制的反转的恢复，实现了更好的关注点分离。

### 综上，从本质上说， evt 对象就是分离的关注点之间一个中立的第三方协商机制。

### Promise “事件”
* **事件侦听 evt 就是 Promise的一个模拟**。
* 在基于Promise的方法中，前面的代码片段会让foo(..)创建并返回一个Promise实例，而且这个Promise会被传递到bar(..)和baz(..)。
> 我们侦听的Promise决议“事件”，严格来说并不算是事件（尽管它们实现目标的行为方式确实很像事件），通常也不叫“completion”或"error"。
> 事实上，我们通过 then(..) 注册一个 "then" 事件。或者可能更精确地说，**then(..)注册“fullfillment” 和 "rejection"事件**，尽管我们并不会在代码中直接使用这些术语。


### revealing constructor
```
    function foo(x) {
        // 开始做一些可能很耗时的工作

        // 构造并返回一个promise
        return new Promise(function(resolve, reject){
            // 最终调用resolve()或者reject()
            // 这是这个promise的决议回调
        })
    }

    var p = foo(42)

    bar(p)

    baz(p)
```
> new Promise(function(..){..}) 模式通常称为 revealing constructor。
> **传入的函数会立即执行**（不会像then(..)中的回调一样异步延迟）。
> **它有两个参数，在本例中我们将其分别称为 resolve和reject。这些是 promise的决议函数。 resolve(..)通常标识完成。而reject(..)则标识拒绝**。

### Promise 可以只作为一种流程控制信号（重点！！！！）
一种做法是：
```
    function bar(fooPromise) {
        // 侦听 foo(..)的完成
        fooPromise.then(
            function(){
                // foo(..)已经完毕，所以执行bar(..)的任务
            },
            function(){
                // 啊， foo(..)中出错了~
            }
        )
    }

    // 对于 baz(..)也是一样
```

另一种做法：
```
    function bar() {
        // foo(..)肯定已经完成，所以执行bar(..)的任务
    }

    function oopsBar() {
        // 啊，foo(..)中出错了，所以bar(..)没有运行
    }

    // 对于baz() 和 oppsBaz() 也是一样

    var p = foo(42)

    p.then(bar, oopsBar)

    p.then(baz, oopsBaz)
```
> 第二种做法中，我们没有把 promise p 传给 bar(..) 和 baz(..)，而是使用 promise 控制 bar(..)和baz(..)何时执行，如果执行的话，最主要的区别在于错误处理部分。

> 且，bar(..)只有在 foo(..)成功时才会被调用，否则就会调用 oopsBar(..)， baz(..)也是如此。

> 在第一种做法中，无论foo(..)成功与否，bar(..)都会被调用，并且如果收到了foo(..)失败的通知，它会亲自处理自己的回退逻辑。显然baz(..)也是如此。

* 这两个方法本身谈不上对错，各自适用于不同的情况。

* 不管哪种情况，都是从 foo(..) 返回的 promise p 来控制接下来的步骤。

* 另外，**一旦p决议，不论是现在还是将来，下一个步骤总是相同的**。

* Promise 一旦决议，一直保持其决议结果（完成或拒绝）不变，可以按照需要多次查看。
