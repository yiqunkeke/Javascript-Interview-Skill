### “进程”
* “进程”---我们用“进程”来表示任务。
* 此进程并非计算机科学意义上的真正操作系统级进程。表示虚拟进程，或者任务。

### 并发
* 定义：两个或多个“进程”同时执行就出现了并发。
* 不管组成它们的单个运算是否并行执行。
* 可以把**并发**看作“进程”级（或者任务级）的并行。与运算级的并行相对。

### 事件顺序执行
* “进程”可以并发运行（任务级并行）
* 但由于在事件循环中，js一次只能处理一个事件。
* 所以“进程”中的各个事件，在事件循环队列中依次运行的。
 
1. 非交互
    * 两个或多个“进程”在同一个程序内并发地交替运行它们的步骤/事件时，如果这些任务彼此不相关，就不一定需要交互。
    * **如果进程间没有相互影响的话，不确定性是完全可以接受的**。

2. 交互
    * 并发的“进程”需要相互交流，通过作用域或DOM间接交互。
    * 这就需要**协调交互顺序**，来处理竞态条件。    
    * 协调的方法-----条件判断if：
        1. if(a && b) ---门 gate
        ```
            var a, b;
            function foo(x) {
                a = x * 2;
                if(a && b) { // 虽然无法确定a和b的到达顺序，但是加上if(a && b)会等到它们两个都准备好再进一步打开门(调用baz())
                    baz();
                }
            }
            function bar(y) {
                b = y * 2;
                if(a && b) {
                    baz();
                }
            }
            function baz() {
                console.log(a + b);
            }

            ajax("http://some.url.1", foo)
            ajax("http://some.url.2", bar)
        ```
        2. if(!a)---门闩 latch:只有第一名取胜。
        ```
            var a;
            function foo(x) {
                a = x * 2;
                if(!a) { // 如果不加门闩，则无论foo和bar哪个后被触发，都会覆盖a值，同时重复调用baz。
                    baz();
                }
            }
            function bar(y) {
                a = y * 2;
                if(!a) {
                    baz();
                }
            }
            function baz() {
                console.log(a);
            }

            ajax("http://some.url.1", foo)
            ajax("http://some.url.2", bar)
        ```
        条件判断if(!a)使得只有foo和bar中的第一个可以通过，第二个调用会被忽略。也就是说第二名没有任何意义。

3. 协作
    * 一个“进程”需要处理大量运算，耗时长，很可能导致页面上其他代码都不能运行，且UI刷新（像滚动、输入、按钮点击）等用户操作都无法进行。
    * 所以，要创建一个**协作性**更强更友好且不会霸占事件循环队列的并发系统，可以异步处理这些结果。每次处理之后返回事件循环，让其他等待事件有机会运行。
    * service-worker的作用就是为了解决上述问题。
    * 也可以将需要处理的数据进行分割，分批次处理数据。
    * 因为事件循环队列的交替运行会提高站点/app的响应（性能）。




