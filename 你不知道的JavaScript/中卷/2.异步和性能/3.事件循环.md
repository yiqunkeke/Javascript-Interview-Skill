### 事件循环
* 直到ES6，js才真正内置有直接的异步概念。
* js引擎职责-----在需要的时候，在给定的任意时刻执行程序中的单个代码块。


* 定义：一种机制来处理程序中多个块的执行，且执行每块时调用js引擎。
* 这种机制被称作事件循环。
* **事件循环的每一轮称为一个 tick**。
* 对每个tick而言，如果队列中有等待事件，就会从队列中摘下一个事件并执行。这些事件就是你的回调函数。
* 事件循环队列中的事件，是**顺序执行**的。

### 宿主环境----浏览器和服务器
* `js引擎`不是独立运行的，它运行在`宿主环境`中。
* 通常来说宿主环境就是web浏览器。
* 随着近几年的发展，js已经超出了浏览器的范围，进入了其他环境。
* 比如 node.js这样的工具就进入服务器领域。

### js引擎
* **js引擎本身并没有时间概念。只是一个按需执行js任意代码块的环境**。
* “事件”（js代码被执行）调度总是由包含它的环境进行。

### 例子
* js发出一个ajax请求，从服务器获取一些数据，那你就在一个函数（通常称为回调函数）中设置好响应代码
* 然后js引擎会通知宿主环境：
* 嘿，现在我要暂停执行，你一旦完成网络请求，拿到了数据，就请调用这个函数
* 然后浏览器（宿主环境）就会设置侦听来自网络的响应，拿到要给你的数据之后，就会把回调函数插入到事件循环，以此实现对这个回调的调度执行。

### 总结：
* js引擎只负责执行js代码块----相当于工厂里面的机器
* 环境负责在某个时刻把回调函数放入事件循环中。------相当于指挥

### 一定要清楚
* setTimeout(..)并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，**环境**会把你的回调函数放在事件循环中。
* 这样在未来的某个时刻的tick会摘下并执行这个回调。

### 不支持抢占式
* 如果事件循环中已经有20个项目，则回调会等待。它会排在其他项目后面
* ----通常没有抢占式支持直接将其排在队首。
* 这也解释了为什么setTimeout(..)定时器的精度可能不高。
* 大体来说，只能确保你的回调函数不会在指定的时间间隔之前运行，但可能会在那个时候运行，也可能在那之后运行，要根据事件队列的状态而定。

### 一句话
* 程序通常分成了很多小块，在事件循环队列中一个接一个地执行。
* 严格的说，和你程序不直接相关的其他事件也可能会插入到队列中。

### tips
> * 上面提到的“直到最近”是指ES6从本质上改变了在哪里管理事件循环。
> * ES6精确指定了事件循环的工作细节，这意味着在技术上将其纳入了js引擎的势力范围，而不是由宿主环境来管理。
> * 这个改变的一个主要原因是ES6中Promise的引入，因为这项技术要求对事件循环队列的调度运行能够直接进行精细控制。




