### Promise信任问题
* 未来值
* 完成事件
* 信任问题

* 回调编码的信任问题：
    * 调用回调过早
    * 调用回调过晚
    * 调用回调次数过多或过少
    * 未能传递所需的环境和参数
    * 吞掉可能出现的错误和异常

* Promise的特性就是专门针对这些问题提供一个有效的可复用的答案。

### 调用过早 
* 担心：一个任务有时同步完成，有时异步完成，这可能会导致竞态条件。
* 根据定义，Promise就不必担心这种问题，因为即使是立即完成的Promise，也无法被同步观察到。
* 如 new Promise(function(resolve){resolve(42)})---立即完成，但依然不会被同步观察到。
* 也就是说，对一个Promise调用then()的时候**总会异步**。即使这个Promise已经决议。

### 调用过晚
* **只要调用resolve()或reject(),then()就一定会调用**。
* Promise创建对象调用resolve(..)或reject(..)时，这个Promise的then(..)注册的观察回调就会被自动调度。
* 可以确信，这些被调度的回调在下一个异步事件点上一定会被触发。


* 同步查看是不可能的，所以一个同步任务链无法以这种方式运行来实现按照预期有效延迟另一个回调的发生。
* 也就是说，一个Promise决议后，这个Promise上所有的通过then()注册的回调都会在下一个异步时机点上依次被立即调用。
* 这些回调中的任意一个都无法影响或延迟对其他回调的调用。

### 例子：
```
    // 第一个p.then事件
    p.then(function() {
        p.then(function() {
            console.log("C")
        })
       console.log("A") 
    })

    // 第二个p.then事件
    p.then(function(){
        console.log("B")
    })
```
* 执行过程：（事件循环与任务队列）
    1. 在事件循环队列中，有两个p.then事件依次等待执行。
    2. 在事件循环的tick结尾处，有一个任务队列。初始状态下，任务队列是空。
    3. 执行第一个p.then事件：
        * 由于**then回调总会异步执行**，所以会在当前tick的任务队列末尾添加一个任务。
        * （异步动作不会导致一个完整的新事件添加到事件循环队列中）
        * 此时，任务队列中存在一个项目：
            // 项目1
            ```
                p.then(function(){
                    console.log("C")
                })
                console.log("A")
            ```
    4. 接着执行第二个p.then事件：
        * 同理，由于异步会在当前tick的任务队列末尾再插入一个新项目
        // 项目2
        ```
            console.log("B")
        ```        
        * 此时，当前tick的任务队列中存在了“项目1”和“项目2”两个任务（项目）。
    5. 事件循环队列中两个p.then事件执行完毕，到了事件循环结尾处。
    6. 开始执行当前事件循环tick的任务队列：
        * 首先执行项目1：
            * 由于项目1中存在p.then是异步，会引起另一个新任务被添加到同一个任务队列末尾（我们叫它项目3）。
            // 项目3
            ```
                console.log("C")
            ```
            * 此时任务队列中存在“项目1”“项目2”“项目3”，3个任务。
            // 项目1
            ```
                p.then(function(){
                    console.log("C")
                })
                console.log("A")
            ```
            // 项目2
            ```
                console.log("B")
            ``` 
            // 项目3
            ```
                console.log("C")
            ``` 
            * 处理完项目1中的p.then之后，会接着执行打印A。
            * 项目1执行结束
        * 接着执行项目2，打印B
        * 最后执行项目3，打印C



