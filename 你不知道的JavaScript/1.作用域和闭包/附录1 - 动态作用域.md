## 动态作用域

在第2章中，我们对比了动态作用域和词法作用域，JavaScript中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的）。

我们会简要地分析动态作用域，重申它与词法作用域的区别。但实际上**动态作用域是JavaScript另一个重要机制this的表亲**。在 "this 和对象原型" 中会有详细介绍

词法作用域是一套关于引擎如何寻找变量以及在何处找到变量的规则。词法作用域最重要的特征是**它的定义过程发生在代码的书写阶段**(假设你没有使用eval()或with)。

动态作用域似乎暗示有很好的理由让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式，事实上也是这样的。示例：

```
	function foo(){
		console.log(a); // 2
	}
	
	function bar(){
		var a = 3;
		foo();
	}
	
	var a = 2;
	
	bar();
```

**词法作用域**让 foo() 中的 a 通过 **RHS** 引用到了全局作用域中的 a，因此会输出2 。

而**动态作用域**并不关心函数和作用域是如何声明以及在何处声明的，只关心它们**从何处调用**。换句话说，**作用域链是基于调用栈的，而不是代码中的作用域嵌套**。

因此，如果 JavaScript具有动态作用域，理论上，上面的代码中的foo()在执行时会输出3。

为什么会这样？因为当 foo()无法找到变量 a 的引用时，会顺着**调用栈**在调用foo()的地方查找a，而不是在嵌套的词法作用域链中向上查找。由于 foo()是在 bar()中调用的，引擎会检查bar()的作用域，并在其中找到值为3的变量 a 。

很奇怪吧？现在你可能会这么想。

但这其实是因为你可能只写过基于词法作用域的代码（或者至少以词法作用域为基础进行了深入的思考），因此对动态作用域感到陌生。如果你只用基于动态作用域的语言写过代码，就会觉得这是很自然的，而词法作用域看上去才怪怪的。

需要明确的是，**事实上，JavaScript并不具有动态作用域。它只有词法作用域，简单明了**。但是，**this机制某种程序上很像动态作用域**。

主要区别：**词法作用域是在写代码或者说定义时确定的，而动态作用域是运行时确定的**。
**this也是！**

**词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用**。

最后，**this关注函数如何调用**，这就表明了 this 机制和动态作用域之间的关系多么亲密。
如果想了解更多关于this的详细内容，可以看“this和对象原型”章节。



