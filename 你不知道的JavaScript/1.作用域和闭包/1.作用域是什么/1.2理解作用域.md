##　理解作用域

```
	var a = 2 ;
```

### 1.上述源代码执行的过程中，都有以下`演员参与`：

1. 引擎

从头到尾负责整个 JavaScript程序的编译及执行过程。

2. 编译器

负责词法分析、语法分析(也叫`解析`)、代码生成等脏活累活。（见1.1编译原理）

3. 作用域

负责收集并维护由所有声明的标识符（变量）组成的一系列查询。并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

简单来讲，就是负责`变量`的`查询`和`访问权限`，供`编译器`和`引擎`来查询。

----------------------------------------------------------------------------------------------------

### 2.`过程`：

当`引擎`看到`var a = 2;`这段程序时，会认为这里有两个不同的声明：一个由`编译器`在编译时处理，另一个则由`引擎`在运行时处理。


`编译器`的处理：
	
  1. 遇到 var a，编译器会询问`作用域`：在同一个作用域中是否已经存在一个该名称的变量？
  
  如果是：则编译器会忽略该声明，继续进行编译；
  如果否，则编译器会要求`作用域`在当前作用域的集合中声明一个新的变量，并命名为 a 
  
  2. 接下来，编译器会为`引擎`生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。
  
  
运行时`引擎`的处理：
  
  引擎会首先询问`作用域`：在当前作用域集合中是否存在一个叫作 a 的变量？
  
  如果是：引擎就会使用这个变量；
  如果否，引擎会继续查找该变量；
  如果引擎最终找到了变量 a ，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常。
  
由此看出，`引擎`和`编译器`都会访问`作用域`。

`总结`: 变量的赋值操作会执行两个动作：首先`编译器`会在当前作用域中声明一个变量（如果之前没有声明过它），然后在运行时，`引擎`会在作用域中查找该变量，如果能找到就对它赋值。
	
-----------------------------------------------------------------------------------------------------	

### 3.`编译器`有话说：（了解编译器术语）

编译器在编译过程的第二步中生成代码，引擎执行它时，会通过变量 a 来判断它是否已声明过。查找的过程由`作用域`协助。但是引擎执行怎样的查找，会影响最终的查找结果。

在我们的例子中，引擎会为变量 a 进行 `LHS` 查询。另一个查找的类型叫 `RHS`。

即，当变量出现在`赋值操作`的左侧时进行 LHS查询(`为了取变量容器`)，出现在右侧时进行 RHS 查询(`为了取值`)。


`RHS 举例`：

```
	console.log( a );
```

上面源码中，对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取得 a 的`值`，这样才能传递给 console.log(..)


`LHS 举例`：

```
	a = 2;
```

上面代码中，对 a 的引用是 LHS 引用，因为实际我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。

> 可以把 RHS 理解为内存右侧的`值查询`，即查找内存中这个变量的值。
> 把 LHS 理解为内存左侧的`变量地址查询`


`综合 举例`（既有 `LHS` 也有 `RHS`）：

```
	function foo(a) {
		console.log(a); // console.log(..)---> RHS、 a--->RHS
	}
	
	foo(2); // foo--> RHS、a ---> LHS
```

上面，对 foo(..)函数的调用需要对 foo 进行 RHS 引用，意味着 “去找到 foo 的值，并把它给我”。
并且(..)意味着 foo 的值需要被执行，因此它最好真的是一个函数类型的值！

代码中隐式的 a = 2 操作可能很容易被你忽略掉。这个操作发生在 2 被当作参数传递给 foo(..)函数时，2会被分配给参数 a 。
为了给参数a(隐式地)分配值，需要进行一次LHS查询。

这里还有对 a 进行的 RHS 引用，并将得到的值传给了 console.log(..)。
console.log(..)本身也需要一个引用才能执行，因此会对 console 对象进行 RHS查询，并且检查得到的值中是否有一个叫log的方法。

--------------------------------------------------------------------------------------------

### 4.`引擎`和`作用域`的对话：我们把综合举例的代码想象成下面的对话


引擎：我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？

作用域: 别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。

引擎：哥们太够意思了！ 好吧，我来执行一下 foo。

引擎：还有个事儿，我需要为 a 进行 LHS 引用，这个你见过吗？

作用域： 这个也见过，编译器最近把它声明为 foo 的一个形参了，拿去吧。

引擎：大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。

引擎：哥们，不好意思又来打扰你。我要为 console 进行 RHS引用，你见过它吗？

作用域： 咱俩谁跟谁啊，再说我就是干这个。这个我也有， console 是个内置对象。给你。

引擎： 么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。

引擎：哥们，能帮我再找一下对 a 的 RHS引用吗？虽然我记得它，但想再确认一次。

作用域： 放心吧，这个变量没有变动过，拿走，不谢。

引擎： 真棒。我来把 a 的值，也就是 2, 传递给 log(..)。

--------------------------------------------------------------------------------

### 5.`小测验`：

```
	function foo(a) {
		var b = a;
		return a + b;
	}
	var c = foo(2);
```

1. foo --> RHS

2. a = 2 ---> a: LHS  // 隐式变量分配

3. var b ---> b: LHS

4. = a --> a: RHS

5. return --> RHS

6. return a + b --> RHS 

7. var c ---> LHS

