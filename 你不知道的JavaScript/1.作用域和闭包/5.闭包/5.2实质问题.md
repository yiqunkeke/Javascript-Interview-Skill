## 实质问题

### 1. 闭包的定义

**当函数可以记住并访问所在的`词法作用域`，就产生了闭包，即使函数是在当前词法作用域之外执行**。

```
	function foo(){
		var a = 2;
		
		function bar(){
			console.log(a);
		}
		
		bar();
	}
	
	foo();
```

这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查找规则，函数 bar() 可以访问外部作用域中的变量 a（这个例子中的是一个 RHS 引用查询）

这是闭包吗？

技术上来讲，`也许是`。但根据前面的定义，`确切地说并不是`。我认为最准确地用来解释 bar() 对 a 的引用的方法是**词法作用域的查找规则，而这些规则只是闭包的一部分**。（但却是非常重要的一部分！）

**重点**：

> 从纯学术的角度说，在上面的代码片段中，函数 bar() 具有一个涵盖 foo()作用域的`闭包`（事实上，涵盖了它所能访问的所有作用域，比如全局作用域）。
> 也可以认为 **bar()封闭了 foo()的作用域**。为什么呢？原因简单明了，因为 bar() 嵌套在 foo()内部。

但是通过这种方式定义的闭包并不能直接**进行观察**，也无法明白在这个代码片段中闭包是**如何工作**的。我们可以很容易地理解**词法作用域**，而闭包则隐藏在代码之后的神秘阴影里，并不那么容易理解。

下面我们来看一段代码，清晰的展示了闭包：

-------------------------------------------------

### 2. 函数作为返回值

```
	function foo() {
		var a = 2;
		
		function bar(){
			console.log(a);
		}
		
		return bar;
	}
	
	var baz = foo(); 
	
	baz(); // 2 -朋友，这就是闭包的效果
```

函数bar()的词法作用域能够访问 foo()的内部作用域。然后我们将 bar()函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。

在 foo()执行后，其返回值（也就是内部的 bar()函数）赋值给变量 baz并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。

bar()显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域**以外**的地方执行。

-----------------------------------------------

### 3. 闭包缺陷

上个例子中，在 foo()执行后，通常会期待 foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器来释放不再使用的内存空间。由于看上去 foo()的内容不会再被使用，所以很自然地会考虑对其进行**回收**。

而闭包的“神奇”之处正是可以**阻止回收**的发生。事实上，内部作用域**依然存在**，因此没有被回收。谁在使用这个内部作用域？原来是 bar()本身在使用。

拜 bar() 所声明的位置所赐，**它拥有涵盖 foo()内部作用域的闭包，使得该作用域能够一直存活**，以供 bar()在之后任何时间进行引用。

bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。

因此，在几微妙之后变量 baz被实际调用（调用内部函数 bar），不出意外它可以访问定义时的词法作用域，因此它可以如预期般访问变量 a 。

这个函数在定义时的词法作用域以外的地方被调用。**闭包使得函数可以继续访问定义时的词法作用域。**

当然，无论使用何种方式(返回值或参数)对函数类型的值**进行传递**。

### 4. 函数作为参数

```
	function foo(){
		var a = 2;
		
		function baz() {
			console.log(a); // 2
		}
		
		bar(baz);
	}
	
	function bar(fn) {
		fn();  //妈妈快看呀，这就是闭包！
	}
```

把内部函数 baz 传递给 bar()，当调用这个内部函数时（现在叫 fn）,它涵盖的 foo()内部的作用域的闭包就可以观察到了，因为它可以访问 a 。

传递函数当然也可以是间接的。

```
	var fn;
	
	function foo() {
		var a = 2;
		
		function baz() {
			console.log(a);
		}
		
		fn = baz;
	}
	
	function bar() {
		fn();
	}
	
	foo();
	
	bar(); // 2

```

无论通过何种手段**将内部函数传递到所在词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会作用闭包**。


