## 模块

还有其它的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究其中最强大的一个：**模块**。

```
	function foo() {
		var something = "cool";
		var another = [1,2,3];
		
		function doSomething(){
			console.log(something);
		}
		
		function doAnother(){
			console.log(another.join('!'));
		}
	}
```

正如这段代码中所看到手，这里并没有明显的闭包，只有两个私有数据变量 something 和 another ，以及 doSomething() 和 doAnother() 两个内部函数，它们的词法作用域（而这就是闭包）就是foo()的内部作用域。

----------------------------------------------------

```
	function CoolModule() {
		var something = "cool";   // 私有变量
		var another = [1,2,3];   
		
		// 内部方法 == 闭包
		function doSomething() {
			console.log(something);
		}
		
		function doAnother() {
			console.log(another.join('!'));
		}
		
		// 返回 - 内部方法（暴露模块）
		return {
			doSomething: doSomething,
			doAnother: doAnother
		};
	}
	
	var foo = coolModule(); 
	
	foo.doSomething();
	foo.doAnother();
```

**这个模式在 JavaScript中被称为模块**。最常见的实现模块模式的方法通常被称为**模块暴露**，这里展示的是其变体。

----------------------------------------------------

我们仔细研究一下这些代码。

1. 首先，CoolModule() 只是一个函数， 必须要通过**调用它**来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法创建。

2. 其次，CoolModule() 返回一个对象字面量语法 {key: value,...}来表示的对象。这个返回的对象中含有对内部函数而**不是**内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个**对象类型的返回值**看作本质上是**模块的公用API**

这个对象类型的返回值最终被赋值给外部的变量 foo，然后就可以通过它来访问API中的属性方法，比如 foo.doSomething()。

> **从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数**。jQuery就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery模块的公共 API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属性）。

（对比构造函数与实例 <---> 模块与实例）

3. doSomething() 和 doAnother() 函数具有**涵盖模块实例内部**作用域的闭包（通过调用CoolModule()实现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创造了可以观察和实践闭包的条件。

------------------------------------------------

### 1. 总结，模块模式需要具备的两个必要条件

1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。

2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

---------------------------------------------------

### 2.一个具有函数属性的对象本身并不是*真正*的模块

从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是**真正**的模块。

--------------------------------------------------

### 3. 单例模式的模块

上一个示例中有一个叫作 CoolModule()的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实例单例模式：

```
	var foo = (function CoolModule(){
		var something = "cool";
		var another = [1,2,3];
		
		function doSomething() {
			console.log(something);
		}
		
		function doAnother() {
			console.log(another.join('!'));
		}
		
		return {
			doSomething: doSomething,
			doAnother: doAnother
		}
	})();
	
	foo.doSomething(); // cool
	foo.doAnother(); // 1 ! 2 ! 3 !
	
```

我们将模块函数转换成了IIFE，**立即**调用这个函数并将返回值赋值给单例的模块实例标识符 foo。

### 4. 模块也是普通函数，可以接受参数

```
	function CoolModule(id) {
		function identify() {
			console.log(id);
		}
		
		return {
			identify: identify
		};
	}
	
	var foo1 = CoolModule('foo 1');
	var foo2 = CoolModule('foo 2');
	
	foo1.identify(); // 'foo 1'
	foo2.identify(); // 'foo 2'
	
```

### 5.命名将要作为公共API返回的对象

模块模式另一个简单但强大的用法是命名将要作为公共API返回的对象

```
	var foo = (function CoolModule(id){
		function change() {
			publicAPI.identify = identify2
		}
		
		function identify1() {
			console.log(id);
		}
		
		function identify2() {
			console.log(id.toUpperCase());
		}
		
		var publicAPI = {
			change: change,
			identify: identify1
		}
		
		return publicAPI;
	})('foo module');
	
	foo.identify(); // foo module
	foo.change();
	foo.identify(); // FOO MODULE
	
```

通过在模块实例的内部保留对公共API对象的内部引用，可以从**内部**对模块实例进行修改，包括添加或删除方法和属性，**以及**修改它们的值。

