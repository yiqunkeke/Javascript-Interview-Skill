## 现在我懂了

前面的代码片段有点死板，并且为了解释如何使用闭包而人为地在结构上进行了修饰。但我保证闭包绝不仅仅是一个好玩的玩具。你已经写过的代码中一定到处都是闭包的身影。

现在我们来 **搞懂**这个事实。

```
	function wait(message) {
		setTimeout(function timer() {
			console.log(message);
		}, 1000);
	}
	
	wait("hello, closure");
```

将一个内部函数（timer()）传递给 setTimeout(..)。 **timer() 具有涵盖 wait(..)作用域的闭包**，因此还 **保有对变量 message的引用**。

wait(..)执行 1000 毫秒后，它的内部作用域并不会消失，timer()函数依然保有 wait(..)作用域的闭包。

在引擎内部，内置的工具函数 setTimeout(..)持有对一个参数的引用，这个参数也许叫作 fn或者 func，或其它类型的名字。**引擎会调用这个函数**，在例子中就是内部的 timer() 函数，而词法作用域在这个过程中 **保持完整**。

**这就是闭包**。

本质上，**无论何时何地，如果将函数当作第一级的值类型并到处传递**，你就会看到闭包在这些函数中的应用。

在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers 或者任何其它的异步（或者同步）任务中，只要使用了 **回调函数**，实际上就是在使用闭包！

