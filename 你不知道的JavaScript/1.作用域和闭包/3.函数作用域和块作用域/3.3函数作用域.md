## 函数作用域

我们已经知道，在任意代码片段外部添加`包装函数`，可以将内部的变量和函数定义“隐藏”起来，外部作用域`无法`访问`包装函数内部`的任何内容。

例如：

```
	var a = 2;
	
	function foo() { // <---添加这一行
		
		var a = 3;
		console.log(a); // 3
		
	} // <---以及这一行
	
	foo(); // <---以及这一行
	
	console.log(a); //2
	
```

虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。

首先，必须声明一个具名函数 foo()，意味着 foo 这个名称本身就**"污染"了所在作用域**(在这个例子中是全局作用域)。

其次，必须**显式地**通过函数名 foo() **调用这个函数**才能运行其中的代码。

如果函数**`不需要函数名`**（或者至少函数名可以不污染所在作用域），并且能够**`自动运行`**，这将更加理想。

幸好，JavaScript提供了能够同时解决这两个问题的方案。

------------------------------------------------------

###　1.函数表达式

```
	var a = 2;
	
	(function foo() { // <---添加这一行
		
		var a = 3;
		console.log(a); // 3
		
	})(); // <--- 以及这一行
	
	console.log(a); // 2
```

接下来我们分别介绍这里发生的事情。

首先，包装函数的声明以 (function...开始，注意前面有小括号。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作`函数表达式`而不是一个标准的`函数声明`来处理。

> 如何区分`函数声明`和`函数表达式`：
> 看 function 关键字出现在声明中的位置。如果 function 是声明中的第一个词，那么就是函数声明。否则就是一个函数表达式。

**`函数声明`和`函数表达式`之间最重要的区别是它们的名称标识符绑定在何处。**

比较一下前面两个代码片段：

第一个片段中 foo 被绑定在所在作用域中，可以直接通过 foo() 来调用它。第二个片段中，foo 被绑定在函数表达式自身的函数中而不是所在作用域中。

换句话说，(function foo() {..}) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。 foo 变量名`被隐藏在自身中`意味着不会非必要地污染外部作用域。

----------------------------------------

### 2.匿名和具名



















