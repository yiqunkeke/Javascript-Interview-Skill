## 函数作用域

我们已经知道，在任意代码片段外部添加`包装函数`，可以将内部的变量和函数定义“隐藏”起来，外部作用域`无法`访问`包装函数内部`的任何内容。

例如：

```
	var a = 2;
	
	function foo() { // <---添加这一行
		
		var a = 3;
		console.log(a); // 3
		
	} // <---以及这一行
	
	foo(); // <---以及这一行
	
	console.log(a); //2
	
```

虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。

首先，必须声明一个具名函数 foo()，意味着 foo 这个名称本身就**"污染"了所在作用域**(在这个例子中是全局作用域)。

其次，必须**显式地**通过函数名 foo() **调用这个函数**才能运行其中的代码。

如果函数**`不需要函数名`**（或者至少函数名可以不污染所在作用域），并且能够**`自动运行`**，这将更加理想。

幸好，JavaScript提供了能够同时解决这两个问题的方案。

------------------------------------------------------

### 1.函数表达式

```
	var a = 2;
	
	(function foo() { // <---添加这一行
		
		var a = 3;
		console.log(a); // 3
		
	})(); // <--- 以及这一行
	
	console.log(a); // 2
```

接下来我们分别介绍这里发生的事情。

首先，包装函数的声明以 (function...开始，注意前面有小括号。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作`函数表达式`而不是一个标准的`函数声明`来处理。

> 如何区分`函数声明`和`函数表达式`：
> 看 function 关键字出现在声明中的位置。如果 function 是声明中的第一个词，那么就是函数声明。否则就是一个函数表达式。

**`函数声明`和`函数表达式`之间最重要的区别是它们的名称标识符绑定在何处。**

比较一下前面两个代码片段：

第一个片段中 foo 被绑定在所在作用域中，可以直接通过 foo() 来调用它。第二个片段中，foo 被绑定在函数表达式自身的函数中而不是所在作用域中。

换句话说，(function foo() {..}) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。 foo 变量名`被隐藏在自身中`意味着不会非必要地污染外部作用域。

----------------------------------------

### 2.匿名和具名

对于`函数表达式`你最熟悉的场景可能就是`回调参数`了，比如：

```
	setTimeout(function() {
		console.log('I waited 1 second');
	}, 1000);
```

这叫**`匿名函数表达式`**，因为 function().. 没有名称标识符。

**`函数表达式可以是匿名的，而函数声明则不可以省略函数名`**。

匿名函数表达式的缺点：

* 匿名函数在栈追踪中不会显示出有意义的函数名，使得`调试很困难`。

* 如果没有函数名，当函数需要引用自身时只能使用已经`过期`的 arguments.callee 引用，比如在递归中。
* 另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。

* 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

**`行内函数表达式`**非常强大且有用 - 匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。**始终给函数表达式命名是一个最佳实践。**

```
	setTimeout(function timeoutHandler(){  // <---快看，我有名字了
		console.log('I waited 1 second');
	}, 1000)
```

--------------------------------------------------------------

### 3.立即执行函数表达式

```
	var a = 2;
	
	(function foo() {
		var a = 3;
		console.log(a); // 3
	})();
	
	console.log(a); // 2
```

运行结果：先打印3，后打印2

分析：**由于函数被包含在一对()括号内部，因此成为了一个表达式，通过在末尾加上另外一个()，可以立即执行这个函数。**

上面例子中，第一个()将函数变成表达式，第二个()执行了这个函数。

> 这种模式很常见，几年前社区给它规定了一个术语：IIFE,代表立即执行函数表达式（Immediately Invoked Function Expression）。
> 函数名对于 IIFE 当然不是必须的，IIFE最常见的用法是使用一个匿名函数表达式。
> 虽然使用具名函数的 IIFE并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。


**`IIFE`另一种写法**

```
	(function(){..}())
```

第一种形式中的函数表达式被包含在()中，然后在后面用另一个()括号来调用。

第二种形式中用来调用的()括号被移进了用来包装的()括号中。

这两种形式功能上是一致的。**`选择哪个全凭个人喜好`**。


**`IIFE`进阶用法**

1. 可以把IIFE当作函数调用`并传递参数进去`。如：

```
	var a = 2;
	
	(function IIFE(global){
		
		var a = 3;
		console.log(a); // 3
		console.log(global.a); // 2
		
	})(window);
	
	console.log(a);
```

我们将window对象的引用传递进去，但将参数命名为 global，因此在代码风格
上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然，可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。

2. 可以使用IIFE解决 undefined标识符的默认值被错误覆盖导致的异常（虽然不常见）。

3. IIFE还有一种变化的用途是`倒置`代码的运行顺序 - 将需要运行的函数放在第二位，**在IIFE执行`之后`当作参数传递进去**。
这种模式在UMD项目中被广泛使用，尽管这种模式略显冗长，但有些人认为它更易理解。

如下：

```
	var a = 2;
	
	(function IIFE(def){
		def(window);
	})(function def(global){
		
		var a = 3;
		console.log(a); // 3
		console.log(global.a); // 2
	});

```

