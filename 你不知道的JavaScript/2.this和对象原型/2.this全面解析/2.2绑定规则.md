## 绑定规则

我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。

你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。

------------------------------------------------

### 1. 默认绑定

首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。

思考一下下面的代码：

```
	function foo() {
		debugger;
		console.log(this.a);
	}
	
	var a = 2;
	
	foo(); // 2
```

你应该注意到的第一件事是，声明在**全局作用域中的变量** a（比如 var a = 2）**就是全局对象的一个同名属性**。它们本质上是同一个东西，并不是通过复制得到的，就像一个硬币的两面一样。

接下来我们可以看到当调用 foo() 时， *this.a 被解析成了全局变量 a*。为什么？因为在本例中，函数调用时应用了 **this 的默认绑定，因此 this 指向全局对象**。

那么我们怎么知道这里应用了**默认绑定**呢？可以通过分析调用位置来看看 foo() 是如何调用的。在代码中，foo()是直接使用**不带任何修饰**的**函数引用**进行调用的，因此**只能使用默认绑定，无法应用其他规则**。

如果使用严格模式（strict mode），则不能将全局对象用于默认绑定，因此 this 会绑定到 undefined:

```
	function foo() {
		"use strict";
		
		console.log(this.a); 
	}
	
	var a = 2;
	
	foo();  // TypeError: Cannot read property 'a' of undefined
```

这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只有 foo()运行在**非 strict mode**下时，默认绑定才能绑定到全局对象；严格模式下调用foo()则不影响默认绑定：

```
	function foo() {
		console.log(this.a);
	}
	
	var a = 2;
	
	(function(){
		"use strict";
		
		foo(); // 2
	})();
```

> 通常来说，你不应该在代码中混合使用 strict 和 非 strict模式。整个程序要么非严格。然而，有时候你可能会用到第三方库，其严格程度和你的代码有所不同，因此一定要注意这类兼容细节。

-------------------------------

### 2.隐式绑定

另一条需要考虑的规则是**调用位置是否有上下文对象**，或者说**是否被某个对象拥有或者包含**，不过这种说法可能会造成一些误导。

思考下面的代码：

```
	function foo() {
		console.log(this.a);
	}
	
	var obj = {
		a: 2,
		foo: foo
	}
	
	obj.foo(); // 2
```

首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。

然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象 “拥有” 或者 “包含” 它。

无论你如何称呼这个模式，当 foo() 被调用时，它的前面确实加了对 obj 的引用。**当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象**。因为调用 foo()时 this被绑定到 obj，因此 this.a 和 obj.a 是一样的。

对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。举例来说：

```
	function foo(){
		console.log( this.a );
	}
	
	var obj2 = {
		a: 42,
		foo: foo
	};
	
	var obj1 = {
		a: 2,
		obj2: obj2
	};
	
	obj1.obj2.foo(); // 42

```

---------------------------------------------------------

**隐式丢失**:
一个最常见的 this 绑定问题就是**被隐式绑定的函数会丢失绑定对象**，也就是说它会应用**默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式**。

思考下面的代码：

```
	function foo() {
		console.log( this.a );
	}
	
	var obj = {
		a: 2,
		foo: foo
	};
	
	var bar = obj.foo; // 函数别名！
	
	var a = "oops, global";  // a 是全局对象的属性
	
	bar();
	
```

**虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。**

----------------------------------------------------

一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：

```
	function foo() {
		console.log(this.a);
	}
	
	function doFoo(fn) {
		// fn 其实引用的是 foo
		
		fn(); // <--调用位置
	}
	
	var obj = {
		a: 2,
		foo: foo
	};
	
	var a = "oops, global";
	
	doFoo(obj.foo); // "oops, global"
```

**参数传递其实就是一种隐式赋值**，因此我们传入函数时也会被隐式赋值，所以结果和上个例子一样。

-----------------------------------------

如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：

```
	function foo() {
		console.log( this.a );
	}
	
	var obj = {
		a:2,
		foo: foo
	};
	
	var a = "oops, global";
	
	setTimeout(obj.foo, 1000); // "oops, global"
	
```

**JavaScript环境中内置的 setTimeout()函数和下面的伪代码类似**：

```
	function setTimeout(fn, delay) {
		// 等待 delay 毫秒
		fn(); // <--调用位置
	}
```

**就像我们看到的那样，回调函数丢失 this 绑定是非常常见的**。除此之外，还有一种情况 this 的行为出乎意料：**调用回调函数的函数可能会修改this**。在一些流行的JavaScript库中事件处理器常会把回调函数的 this 强制绑定到触发事件的DOM元素上。这在一些情况下可能很有用，但是有时它可能会让你感到郁闷。遗憾的是，这些工具通常无法选择是否启用这个行为。

无论是哪种情况，this的改变都是意想不到的，实际上你无法控制回调函数的执行方式，因此就没有办法控制调用位置以得到期望的绑定。之后我们会介绍如何通过固定的 this 来修复这个问题。

------------------------

### 3.显式绑定

