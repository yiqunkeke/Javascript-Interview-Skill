## 绑定例外 

规则总有例外，这里也一样。

在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他规则时，实际上应用的可能是默认绑定规则。

----------------------

### 1. 被忽略的 this

如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。

```
	function foo(){
		console.log(this.a);
	}
	
	var a = 2;
	
	foo.call(null); // 2
```

那么什么情况下你会传入null呢？

一种非常常见的做法是使用 apply(..)来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..)可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：

```
	function foo(a,b) {
		console.log("a:" + a + ",b:" + b);
	}
	
	//把数组“展开”成参数
	foo.apply(null, [2,3]);   // a:2,b:3
	
	// 使用 bind(..)进行柯里化
	var bar = foo.bind(null, 2);
	bar(3);  // a:2,b:3
```

这两种方法都需要传入一个参数当作 this 的绑定对象。如果函数并不关心this的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择，就像代码所示的那样。

> 尽管本书中未提到，但在 ES6中，可以使用 ...操作符来代替 apply(..)来“展开”数组，foo(...[1,2]) 和 foo(1,2) 是一样的，这样可以避免不必要的 this 绑定。可惜，在 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。

然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this（比如第三方库中的一个函数），那默认绑定规则会把this绑定到全局对象（在浏览器中这个对象是 window）,这将导致不可预计的后果（比如修改全局对象）。

显而易见，这种方式可能会导致许多难以分析的追踪的 bug。

---------------

### 2. 更安全的 this

一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序产生任何副作用。就像网络（以及军队）一样，我们可以创建一个“DMZ”（demelitarized zone，非军事区）对象---它就是一个空的非委托的对象（委托在第5和6章介绍）。

如果我们在忽略this绑定时总是传入一个DMZ 对象，那就什么都不用担心了，因为任何对于this的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。

由于这个对象完全是一个空对象，我自己喜欢用变量名Ø（这是数学中表示空集合符号的小写形式）来表示它。无论你叫它什么，**在JavaScript中创建一个空对象最简单的方法都是 Object.create(null)(详细介绍看第5章)。Object.create(null)和{}很像，但是并不会创建Object.prototype这个委托，所以它比{}更空：**

```
	function foo(a, b) {
		console.log("a:" + a +",b:" + b);
	}
	
	// 创建我们的DMZ空对象
	var Ø = Object.create(null);
	
	// 把数组展开成参数
	foo.apply(Ø, [2,3]); // a:2,b:3
	
	// 使用 bind(..)进行柯里化
	var bar = foo.bind(Ø, 2);
	bar(3); // a:2,b:3
```

使用变量名Ø不仅让函数变更更加“安全”，而且可以提高代码的可读性，因为Ø表示“我希望this 是空”，这比 null 的含义更清楚。不过再说一遍，你可以用任何喜欢的名字来命名DMZ对象。

-------

### 3. 间接引用

另外一个需要注意的是，你有可能（有意或者无意地）创建一个 **函数的“间接引用”**，在这种情况下，调用这个函数会 **应用默认绑定**规则。

**间接引用最容易发生在赋值时**：

```
	function foo() {
		console.log(this.a);
	}
	
	var a = 2;
	var o= { a:3, foo:foo};
	var p = {a:4};
	
	o.foo(); // 3
	(p.foo = o.foo)();
```

赋值表达式 p.foo = o.foo 的返回值是 **目标函数的引用**，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会 **应用默认绑定**。

注意：对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数休是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则this会被绑定到全局对象。

------------------------

### 4.软绑定

之前我们已经看到过，硬绑定这种方式可以把this强制绑定到指定的对象（除了使用 new时），防止函数调用应用默认绑定规则。
问题在于，硬绑定会大大降低函数的灵活性，**使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改this**。

如果可以 **给默认绑定指定一个全局对象和 undefined以外的值**，那就可以实现和硬绑定相同的效果，**同时保留隐式绑定或者显式绑定修改this的能力**。

......















































