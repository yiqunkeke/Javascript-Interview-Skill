## “类”

现在你可能会很好奇：为什么一个对象需要关联到另一个对象？这样做有什么好处？这个问题非常好，但是在回答之前我们首先要理解[[Prototype]]“不是”什么。

第4章中我们说过，JavaScript和面向类的语言不同，它并没有类来作为对象的抽象模式或者说蓝图。JavaScript中只有对象。

实际上，JavaScript 才是真正应该被称为“面向对象”的语言，因为它是少有的可以不通过类，直接创建对象的语言。

在JavaScript中，类无法描述对象的行为，（因为根本就不存在类！）对象直接定义自己的行为。**再说一遍，JavaScript中只有对象**。

----------------------------

### “类”函数

多年以来，JavaScript中有一种奇怪的行为一直在被无耻地滥用，那就是模仿类。我们会仔细分析这种方法。

这种奇怪的“类似类”的行为利用了函数的一种特殊特性：**所有的函数默认都会拥有一个名为 prototype 的公有并用不可枚举（参见第3章）的属性，它会指向另一个对象**：

```
    function Foo(){

    }

    Foo.prototype; // {}
```

这个对象通常被称为Foo的原型，因为我们通过名为 Foo.prototype的属性引用来访问它。然而不幸的是，这个术语对我们造成了极大的误导，稍后我们就会看到。如果是我的话就会叫它“之前被称为Foo的原型的那个对象”。好吧我是开玩笑的，你觉得“被贴上‘Foo点prototype’标签的对象”这个名字怎么样？

抛开名字不谈，这个对象到底是什么？

最直接的解释就是，这个对象是在调用 new Foo()（参见第2章）时创建的，最后会被（有点武断地）关联到这个 “Foo.prototype”对象上。

我们来验证一下：

```
    function Foo(){
        // ...
    }

    var a = new Foo();

    Object.getPrototypeOf(a) === Foo.prototype;
```

调用 new Foo()时会创建 a（具体的4个步骤参见第2章），其中一步就是 **将内部的 [[Prototype]] 链接到 Foo.prototype 所指向的对象**。

暂停一下，仔细思考这条语句的含义。

在面向类的语言中，类可以被复制（或者说实例化）多次，就像用模具制作东西一样。我们在第4章中看到过，之所以会这样是因为实例化（或者继承）一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。

但是 **在JavaScript中**，并没有类似的复制机制。你不能创建一个类的多个实例，**只能创建多个对象，它们[[Prototype]]关联的是同一个对象**。但是在默认情况下并 **不会进行复制**，因此这些对象之间并不会完全失去联系，它们是互相关联的。

new Foo() 会生成 一个新对象（我们称之为 a），这个新对象的内部链接[[Prototype]]关联的是 Foo.prototype 对象。

最后我们得到了两个对象，它们之间互相关联，就是这样。我们并没有初始化一个类，**实际上我们并没有从“类”中复制任何行为到一个对象中，只是让两个对象互相关联**。

实际上，绝大多数JavaScript开发者不知道的秘密是， new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用。 new Foo() 只是间接完成了我们的目标：一个关联到其他对象的新对象。

那么有没有更直接的方法来做寿到这一点呢？当然！功臣就是Object.create(..)，不过我们现在暂时不介绍它。

