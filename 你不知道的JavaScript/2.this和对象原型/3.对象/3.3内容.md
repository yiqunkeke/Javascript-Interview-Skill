## 内容

之前我们提到过，对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为 **属性**。

需要强调的一点是，当我们说“内容”时，似乎在暗示这些值实际上被存储在对象内容，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并不会存储在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。

----------------------------------------------------------------

### 1.属性访问与键访问

思考下面的代码：

```
    var myObj = {
        a: 2
    };

    myObj.a; // 2

    myObj["a"]; // 2
```

如果要访问 myObj中的 a 位置上的值，我们需要使用 . 操作符或者 [] 操作符。 **点.a语法通常被称为“属性访问”**，**中括号["a"]语法通常被称为“键访问”**。实际上它们访问的是同一个位置，并且会返回相同的值，所以这两个术语是可以互换的。在本书中我们会使用最常见的术语"属性访问"。

**属性访问与键访问**的区别：

. 操作符要求属性名满足标识符的命名规范，而[".."]语法可以接受任意UTF-8/Unicode字符串作为属性名。举例来说，如果要引用名称为“Super-Fun!”的属性，那就必须使用["Super-Fun!"]语法访问，因为Super-Fun!并不是一个有效的标识符属性名。

此外，由于[".."]语法使用字符串来访问属性，所以可以在程序中构造这个字符串，比如说：

```
    var myObject = {
        a: 2
    };

    var idx;

    if(wantA) {
        idx = "a";
    }

    // 之后

    console.log(myObject[idx]);
```

-----------------------------------------------------------------

### 2.在对象中，属性名永远都是字符串

如果你 string（字面量）以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法：

```
    var myObject = {};

    myObject[true] = "foo";
    myObject[3] = "bar";
    myObject[myObject] = "baz";

    myObject["true"];  // "foo"
    myObject["3"]; // "bar"
    myObject["[object object]"]; // "baz"
```

-------------------------------------------------------

### 3.可计算属性名

如果你需要通过表达式来计算属性名，那么我们刚刚讲到的 myObject[..]这种属性访问语法就可以派上用场了，如可以使用myObject[prefix + name]。但是使用文字形式来声明对象时这样做是不行的。

ES6增加了 **可计算属性名**，可以在文字形式中 **使用 []包裹一个表达式来当作属性名**：

```
    var prefix = "foo";

    var myObject = {
        [prefix + "bar"]: "hello",
        [prefix + "baz"]: "world"
    };

    myObject["foobar"]; // "hello"
    myObject["foobaz"]; // "world"
```

可计算属性名最常用的场景可能是ES6的符号（Symbol）,本书中不作详细介绍。不过简单来说，它们是一种新的基础数据类型，包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到符号的实际值（因为理论上来说在不同的JavaScript引擎中值是不同的），所以通常你接触到的是符号的名称，比如Symbol.Something(这个名字是我编的)：

```
    var myObject = {
        [Symbol.Something]: "hello world"
    }
```

-----------------------------------------------------------

### 4.属性和方法

如果访问的对象属性是一个函数，有些开发者喜欢使用不一样的叫法以作区分。由于函数很容易被误认为是属于某个对象，在其他语言中，属于对象（也被称为“类”）的函数通常被称为“方法”，因此把“属性访问”说成是“方法访问”也不奇怪了。

有意思的是，JavaScript的语法规范也做出了同样的区分。

从技术角度来说，**函数永远不会“属于”一个对象**，所以把对象内部引用的函数称为“方法”似乎有点不妥。

确实，有些函数具有this引用，有时候这些this确实会指向调用位置的对象引用。但是这种用法 **从本质上来说并没有把一个函数变成一个“方法”**，因为 this 是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只是说是 **间接关系**。

无论返回值是什么类型，每次访问对象的属性就是属性访问。**如果属性访问返回的是一个函数，那它也并不是一个“方法”**。属性访问返回的和其他函数没有任何区别（除了可能发生的隐式绑定this，就像我们刚才提到的）。

举例来说：

```
    function foo() {
        console.log("foo");
    }

    var someFoo = foo; // 对 foo的变量的引用

    var myObject = {
        someFoo: foo
    };

    foo; // function foo() {..}

    someFoo;  // function foo() {..}

    myObject.someFoo; // function foo() {..}

```

someFoo 和 myObject.someFoo 只是对于同一个函数的不同引用，并不能说明这个函数是特别的或者“属于”某个对象。如果 foo()定义时在内部有一个this引用，那这两个函数引用的唯一区别就是 myObject.someFoo 中的 this会被隐式绑定到一个对象。无论哪种引用形式都不能称之为“方法”。

或者有人会辩解说，函数并不是在定义时成为方法，而是在被调用时根据调用位置的不同（是否具有上下文对象--详细见第2章）成为方法。即便如此，这种说法仍然有些不妥。

最保险的说法可能是， **函数”和“方法”在JavaScript中是可以互换的**。

> ES6增加了 super 引用，一般来说会被用在 class 中（参见附录A）。super 的行为似乎更有理由把 super 绑定的函数称为 "方法"。但是再说一次，这些只是一些语义（和技术）上的微妙差别，本质是一样的。

即使你在对象中的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象---它们只是对于相同函数对象的多个引用。

```
    var myObject = {
        foo: function(){
            console.log("foo");
        }
    };

    var someFoo = myObject.foo;

    someFoo; // function foo() {..}
    myObject.foo; // function foo() {..}
```

> 第6章会介绍本例对象的文字形式中的声明函数的语法，这是ES6增加的一种简易函数声明语法 

------------------------------------------------------

### 5.数组

数组也支持[]访问形式，不过就像我们之前提到过的，数组有一套更加结构化的值存储机制（不过仍然不限制值的类型）。数组期望的是数值下标，也就是说值存储的位置（通常被称为索引）是非负整数，比如说0 和 42:

```
    var myArray = ["foo", 42, "bar"];

    myArray.length; // 3

    myArray[0];  // "foo"

    myArray[2]; // "bar"
```

**数组也是对象**，所以虽然每个下标都是整数，你仍然可以给数组添加属性：

```
    var myArray = ["foo", 42, "bar"];

    myArray.baz = "baz";

    myArray.length; // 3

    myArray.baz; // "baz"
```

可以看到虽然添加了命名属性（无论是通过.语法还是[]语法），数组的 length值并未发生变化。

你完全可以把数组当作一个普通的键/值对象来使用，并且不添加任何数值索引，但是这并不是一个好主意。数组和普通的对象都根据其对应的行为和用途进行了优化，所以 **最好只用对象来存储键/值对，只用数组来存储下标/值对**。

注意：如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标（因此会修改数组的内容而不是添加一个属性）：

```
    var myArray = ["foo", 42, "bar"];

    myArray["3"] = "baz";

    myArray.length; // 4

    myArray[3]; // "baz"
```

------------------------------

### 6.复制对象

JavaScript 初学者最常见的问题之一就是如何复制一个对象。看起来应该有一个内置的 copy() 方法，是吧？实际上事情比你想象的更复杂，因为我们无法选择一个默认的复制算法。

举例来说，思考下这个对象：

```
    function anotherFunction() { /*..*/}

    var anotherObject = {
        c: true
    };

    var anotherArray = [];

    var myObject = {
        a: 2,
        b: anotherObject,
        c: anotherArray,
        d: anotherFunction
    };

    anotherArray.push(anotherObject, myObject);
```

如何准确地表示 myObject 的复制呢？

首先，我们应该判断它是 **浅复制** 还是 **深复制**。

对于浅拷贝来说，复制出的新的对象中 a 的值会复制旧对象中 a 的值，也就是 2，但是对于新对象中的 b, c, d 三个属性其实只是三个引用，它们和旧对象中 b, c, d 引用的对象是一样的。

对于深复制来说，除了复制 myObject 以外还会复制 anotherObject 和 anotherArray。这里问题就来了，anotherArray 引用了 anotherObject 和 myObject，所以又需要复制 myObject，这样就会由于循环引用导致死循环。

我们是应该检测循环引用并终止循环（不复制深层元素）？还是应该直接报错或者选择其他方法？

除此之外，我们还不确定“复制”一个函数意味着什么。有些人通过 toString()来序列化一个函数的源代码（但是结果取决于JavaScript的具体实现，而且不同的引擎对于不同类型的函数处理方式并不完全相同）。

那么如何解决这些棘手问题呢？许多JavaScript框架都提出了自己的解决办法，但是JavaScript应该采用哪种方法作为标准呢？在很长一段时间里，这个问题都没有明确的答案。

对于JSON安全（也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）的对象来说，有一种 **巧妙的复制方法**：

```
    var newObj = JSON.parse(JSON.stringify( someObj ));
    
```

当然，这种方法需要保证对象是JSON安全的，所以只适用于部分情况。

相比深复制，浅复制非常易懂并且问题要少的多，所以 **ES6定义了 Object.assign(..)方法来实现浅复制**。 Object.assign(..)方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举（enumerable，参见下面的代码）的自有键（owned key，很快会介绍）并把它们复制（使用 = 操作符）到目标对象，最后返回目标对象，就像这样：

```
    var newObj = Object.assign({}, myObject);

    newObj.a; // 2

    newObj.b === anotherObject; // true
    newObj.c === anotherArray; // true
    newObj.d === anotherFunction; // true
```

> 接下来会介绍“属性描述符”以及Object.defineProperty(..)的用法。但是需要注意的一点是，由于Object.assign(..)就是使用 = 操作符来赋值，所以源对象属性的一些特性（比如 writable）不会被复制到目标对象。

-----------------------------------------------------








