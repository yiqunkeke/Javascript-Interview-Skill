## 误解

我们之后会解释 this 到底是如何工作的，但是首先需要消除一些关于 this 的错误认识。

太拘泥于 “this” 的字面意思就会产生一些误解。有两种常见的对于 this的解释，但是它们都是错误的。

---------------------------------------------------

### 1. 指向自身

人们很容易把 this 理解成指向函数自身，这个推断从英语的语法角度来说是说的通的。

那么为什么需要从函数内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写一个在第一次被调用后自己解除绑定的事件处理器。

JavaScript的新手开发者通常会认为，既然把函数看作一个对象（JavaScript中的所有函数都是对象），那就可以在调用函数时存储状态（属性的值）。这是可行的，有些时候也确实有用，但是在本书即将介绍的许多模式中你会发现，除了函数对象还有许多更合适存储状态的地方。

不过现在我们先来分析下这个模式，让大家看到 **this 并不像我们所想的那样指向函数本身**。

我们想要记录下函数 foo 被调用的次数，思考下下面的代码：

```
	function foo(num) {
		console.log(num);
		
		this.count++;
	}
	
	foo.count = 0;
	
	var i;
	
	for(i=0; i<10; i++) {
		if( i>5 ){
			foo(i);  // 6、7、8、9
		}
	}
	
    // foo 被调用了多少次？
	console.log(foo.count); // 0 -- 为什么？
```

console.log语句产生了4条输出，证明 foo(..) 确实被调用了 4 次，但是 foo.count 仍然是 0。**显然从字面意思来理解this是错误的**。

执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相同，困惑随之产生。

> 负责的开发者一定会问“如果我增加的count属性和预期的不一样，那我增加的是哪个count?”实际上，如果深入探索的话，就会发现这段代码在无意中创建了一个全局变量 count(原理参见第2章)，它的值是NaN。当然，如果他发现了这个奇怪的结果，那一定会接着问：“为什么它是全局的，为什么它的值是NaN，而不是其他更合适的值？”（参见第2章）

-------------------------------------------------------------------------------------------------

1. **使用函数名来指向函数本身**：

遇到这样的问题时，许多开发者并不会深入思考为什么 this 的行为和预期的不一致，也不会试图回答那些很难解决但却非常重要的问题。他们只会回避这个问题并使用其他方法来达到目的，比如创建另一个带有 count 属性的对象。

```
	function foo(num) {
		console.log(num);
		
		data.count++;
	}
	
	var data = {
		count: 0
	};
	
	var i;
	
	for(i=0; i<10; i++) {
		if(i>5) {
			foo(i);  // 6、7、8、9
		}
	}
	
	// foo 被调用了多少次？
	console.log(data.count);  // 4
```

从某种角度来说这个方法确实“解决”了问题，但可惜它忽略了真正的问题---无法理解 this 的含义和工作原理---而是返回舒适区，使用了一种更熟悉的技术：词法作用域。

> 词法作用域是一种非常优秀并且有用的技术。我丝毫没有贬低它的意思（可以参考第一部分“作用域和闭包”）。但是如果你仅仅是因为无法猜对 this 的用法，就放弃学习 this 而去使用词法作用域，就不能算是一种很好的解决办法了。

------------------------------------------------------------------------------------------------------------

2. **匿名函数无法使用-标识符来指向函数本身**：

如果要从函数对象内部引用它的自身，那只使用this是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。

思考下下面这两个函数：

```
	function foo() {
		foo.count = 4; // foo 指向它自身
	}
	
	setTimeout(function(){
		// 匿名（没有名字的）函数无法指向自身
	}, 1000)
```

第一个函数被称为具名函数，在它内部可以使用 foo来引用自身。

但是在第二个例子中，传入 setTimeout(..)的回调函数没有标识符（这种函数被称为匿名函数），因此无法从函数内部引用自身。

> 还有一种传统的但是现在已经被弃用和批判的用法，是使用 arguments.callee 来引用当前正在运行的函数对象。这是唯一一种可以从匿名函数对象内部引用自身的方法。然而，更好的方式是避免使用匿名函数，至少在需要自引用时使用具名函数（表达式）。 arguments.callee已经被弃用，不应该再使用它。

-----------------------------------------------------------------

所以，对于我们的例子来说，另一种解决方法是使用 foo标识符替代 this 来引用函数对象：

```
	function foo(num) {
		console.log(num);
		
		foo.count++;
	}
	
	foo.count = 0;
	
	var i = 0;
	
	for(i=0; i<10; i++) {
		if( i> 5) {
			foo(i);
		}
	}
	
	// foo 被调用了多少次？
	console.log(foo.count);  // 4
```

然而，这种方法同样回避了 this 的问题，并且完全依赖于变量 foo 的词法作用域。

3. **另一种方法是强制 this 指向 foo 函数对象**：

```
	function foo(num) {
		console.log(num);
		
		this.count++;
	}
	
	foo.count = 0;
	
	var i;
	
	for(i=0; i<10; i++) {
		if(i>5) {
			// 使用 call(..)可以确保 this指向函数对象 foo 本身
			foo.call(foo, i);
		}
	}
	
	// foo 被调用了多少次？
	console.log(foo.count); // 4
```

这次我们接受了 this， 没有回避它。如果你仍然感到困惑的话，不用担心，之后我们会详细解释具体的原理。

------------------------------------------------------------

### 2. 它的作用域

第二种常见的误解是， this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。

需要明确的是， **this 在任何情况下都不指向函数的词法作用域**。在JavaScript内部，作用域确实和对象类似可见的标识符都是它的属性。但是**作用域“对象”无法通过JavaScript代码访问，它存在于JavaScript引擎内部。**

思考一下下面的代码，它试图（但是没有成功）跨越边界，使用 this 来隐式引用函数的词法作用域：

```
	function foo() {
		var a = 2;
		this.bar();
	}
	
	function bar() {
		console.log(this.a);
	}
	
	foo(); // ReferenceError: a is not defined
```

这段代码中的错误不止一个。虽然这段代码看起来好像是我们故意写出来的例子，但是实际上它是出自一个公共社区中互助论坛的精华代码。这段代码非常完美（同时也令人伤感）地展示了 this 多么容易误导人。

首先，这段代码试图通过 this.bar()来引用bar()函数。这样调用能成功纯属意外，我们之后会解释原因。调用bar()最自然的方法是省略前面的 this，直接使用词法引用标识符。

此外，编写这段代码的开发者还试图使用 this 联通 foo() 和 bar()的词法作用域，从而让 bar()可以访问 foo()作用域里的变量 a。这是不可能实现的，使用 this 不可能在词法作用域中查找到什么。

每当你想要把 this 和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。








