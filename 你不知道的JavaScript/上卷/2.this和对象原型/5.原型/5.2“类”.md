## “类”

现在你可能会很好奇：为什么一个对象需要关联到另一个对象？这样做有什么好处？这个问题非常好，但是在回答之前我们首先要理解[[Prototype]]“不是”什么。

第4章中我们说过，JavaScript和面向类的语言不同，它并没有类来作为对象的抽象模式或者说蓝图。JavaScript中只有对象。

实际上，JavaScript 才是真正应该被称为“面向对象”的语言，因为它是少有的可以不通过类，直接创建对象的语言。

在JavaScript中，类无法描述对象的行为，（因为根本就不存在类！）对象直接定义自己的行为。**再说一遍，JavaScript中只有对象**。

----------------------------

### 1. “类”函数

多年以来，JavaScript中有一种奇怪的行为一直在被无耻地滥用，那就是模仿类。我们会仔细分析这种方法。

这种奇怪的“类似类”的行为利用了函数的一种特殊特性：**所有的函数默认都会拥有一个名为 prototype 的公有并用不可枚举（参见第3章）的属性，它会指向另一个对象**：

```
    function Foo(){

    }

    Foo.prototype; // {}
```

这个对象通常被称为Foo的原型，因为我们通过名为 Foo.prototype的属性引用来访问它。然而不幸的是，这个术语对我们造成了极大的误导，稍后我们就会看到。如果是我的话就会叫它“之前被称为Foo的原型的那个对象”。好吧我是开玩笑的，你觉得“被贴上‘Foo点prototype’标签的对象”这个名字怎么样？

抛开名字不谈，这个对象到底是什么？

最直接的解释就是，这个对象是在调用 new Foo()（参见第2章）时创建的，最后会被（有点武断地）关联到这个 “Foo.prototype”对象上。

我们来验证一下：

```
    function Foo(){
        // ...
    }

    var a = new Foo();

    Object.getPrototypeOf(a) === Foo.prototype;
```

调用 new Foo()时会创建 a（具体的4个步骤参见第2章），其中一步就是 **将内部的 [[Prototype]] 链接到 Foo.prototype 所指向的对象**。

暂停一下，仔细思考这条语句的含义。

在面向类的语言中，类可以被复制（或者说实例化）多次，就像用模具制作东西一样。我们在第4章中看到过，之所以会这样是因为实例化（或者继承）一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。

但是 **在JavaScript中**，并没有类似的复制机制。你不能创建一个类的多个实例，**只能创建多个对象，它们[[Prototype]]关联的是同一个对象**。但是在默认情况下并 **不会进行复制**，因此这些对象之间并不会完全失去联系，它们是互相关联的。

new Foo() 会生成 一个新对象（我们称之为 a），这个新对象的内部链接[[Prototype]]关联的是 Foo.prototype 对象。

最后我们得到了两个对象，它们之间互相关联，就是这样。我们并没有初始化一个类，**实际上我们并没有从“类”中复制任何行为到一个对象中，只是让两个对象互相关联**。

实际上，绝大多数JavaScript开发者不知道的秘密是， new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用。 new Foo() 只是间接完成了我们的目标：一个关联到其他对象的新对象。

那么有没有更直接的方法来做寿到这一点呢？当然！功臣就是Object.create(..)，不过我们现在暂时不介绍它。


1. 关于名称

在 JavaScript 中，我们并不会将一个对象（“类”）复制到另一个对象（“实例”）, 只是将它们关联起来。从视觉角度来说， [[Prototype]]机制如下图所示，箭头从右到左，从下到上：


        Foo.prototype
            
            ↑       ↖  
            │         a1
            │
            │       ↖ 
                        a2  

        Bar.prototype

                    ↖
                    b1
        
                    ↖ 
                    b2  


这个机制通常被称为原型继承（稍后我们会分析具体代码），它常常被视为动态语言版本的类继承。这个名称主要是为了对应面向类的世界中“继承”的意义，但是违背（推翻）了动态脚本中对应的语义。

“继承”这个词会让人产生非常强的心理预期（参见第4章）。仅仅在前面加上“原型”并不能区别出JavaScript中和类继承几乎完全相反的行为，因此在过去20年中造成了极大的误解。

在我看来，在“继承”前面加上“原型”对于事实的曲解就像一只手拿橘子一只手拿苹果然后把苹果叫“红橘子”一样。无论添加什么标签都无法改变事实：一种水果是苹果，另一种是橘子。

更好的方法是直接把苹果叫作苹果----使用更加准确并且直接的术语。这样有助于理解它们的相似之处以及不同之处，因为我们大家都明白“苹果”的含义。

因此我认为这个容易混淆的组合术语“原型继承”（以及使用其他面向类的术语比如“类”、“构造函数”、“实例”、“多态”，等等）严重影响了大家对于JavaScript机制真实原理的理解。

继承意味着复制操作，JavaScript(默认)并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过 **委托**访问另一个对象的属性和函数。**委托（参见第6章）这个术语可以更加准确地描述JavaScript中对象的关联机制**。

还有个偶尔会用到的JavaScript术语--差异继承。基本原则是在描述对象行为时，使用其不同于普遍描述的特质。举例来说，描述汽车时你会说汽车是有4个轮子的一种交通工具，但是你不会重复描述交通工具具备的通用特性（比如引擎）。

如果你把JavaScript中对象的所有委托行为都归结到对象本身并且把对象看作是实物的话，那就（差不多）可以理解差异继承了。

但是和原型继承一次，差异继承会更多是你脑中构建出的模型，而非真实情况。它忽略了一个事实，那就是对象B实际上并不是被差异构造出来的，我们只是定义了B 的一些指定特性，其实没有定义的东西都变成了“洞”。而这些洞（或者说缺少定义的空白处）最终会被委托行为“填满”。

默认情况下，对象并不会像差异继承暗示的那样通过复制生成。因此，差异继承也不适合用来描述JavaScript的[[Prototype]]机制。

当然，如果你喜欢，完全可以使用差异继承这个术语，但是无论如何它只适用于你脑中的模型，并不符合引擎的真实行为。


----------------------------

### 2. “构造函数”

好了，回到之前的代码

```
    function Foo(){
        // ...
    }

    var a = new Foo();

```

到底是什么让我们认为 Foo 是一个“类”呢？

其中一个原因是因为我们看到了 new 关键字。在面向类的语言中构造类实例时也会用到它。另一个原因是看起来我们执行了类的构造函数方法，Foo()的调用方式很像初始化类时类构造函数的调用方式。

除了令人迷惑的“构造函数”语义外， Foo.prototype还有另一个绝招。思考下面的代码：

```
    function Foo(){
        // ...
    }
    
    Foo.prototype.constructor === Foo; // true

    var a = new Foo();

    a.constructor === Foo; // true

```

**Foo.prototype 默认（在代码中第一行声明时！）有一个公用且不可枚举的的属性 .constructor**，这个属性引用的是对象关联的函数
（本例中是 Foo）。此外，我们可以看到 **通过“构造函数”调用 new Foo()创建的对象也有一个 .constructor属性，指向“创建这个对象的函数”**。

实际上 a 本身并没有 .constructor属性。而且 虽然 a.construtor确实指向 Foo 函数，但是这个属性并不是表示 a 由 Foo “构造”，稍后我们会解释。

哦耶，好吧......按照 JavaScript 世界的惯例，“类”名首字母要大写，所以名字写作 Foo 而非 foo 似乎也提示它是一个“类”。显而易见，是吧？！

这个惯例影响力非常大，以至于如果你用 new 来调用小写方法或者不用 new 调用大写的函数，许多JavaScript开发者都会责怪你。这很令人吃惊，我们竟然会如此努力地维护JavaScript中（假）“面向类”的权力，尽管对于JavaScript引擎来说首字母大写没有任何意义。

1. 构造函数还是调用

上一段代码很容易让人认为 Foo是一个构造函数，因为我们使用 new 来调用它并且看到它“构造”了一个对象。

实际上，Foo 和你程序中的其他函数没有任何区别。 **函数本身并不是构造函数**，然而，当你在普通的函数调用前面加上 new 关键字之后，就会把这个函数调用变成一个“构造函数调用”。**实际上， new 会劫持所有普通函数并用构造对象的形式来调用它**。

举例来说：

```
    function NothingSpecial(){
        console.log("Don't mind me!");
    }

    var a = new NothingSpecial();
    // Don't mind me!

    a; // {}
    
```

NothingSpecial 只是一个普通的函数，但是使用 new 调用时，它就会构造一个对象并赋值给 a ,这看起来像是 new 的一个副作用（无论如何都会构造一个对象）。这个调用是一个构造函数调用，但是 NothingSpecial 本身并不是一个构造函数。

**换句话说，在JavaScript中对于“构造函数”最准确的解释是，所有带 new 的函数调用**。

**函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”**。

----------------

### 3. 技术

我们是不是已经介绍了JavaScript中所有和 “类”相关的问题了呢？

不是。 JavaScript 开发者绞尽脑汁想要模仿类的行为：

```
    function Foo(name) {
        this.name = name;
    }

    Foo.prototype.myName = function() {
        return this.name
    }

    var a = new Foo("a");
    var b = new Foo("b");

    a.myName(); // "a"
    b.myName(); // "b"
```

这段代码展示了另外两种“面向类”的技巧：

1. this.name = name 给每个对象（也就是 a 和 b ，参见第2章中的 this 绑定）都添加了 .name 属性，有点像类实例封装的数据值。

2. Foo.prototype.myName = .. 可能是个更有趣的技巧，它会给 Foo.prototype 对象添加一个属性（函数）。 现在 a.myName() 可以正常工作，但是你可能会觉得惊讶，这是什么原理？

在这段代码中，看起来似乎创建 a 和 b 时会把 Foo.prototype 对象复制到这两个对象中，然后事实并不是这样。

在本章开头介绍默认的 [[Get]] 算法时我们介绍过 [[Prototype]] 链，以及当属性不直接存在于对象中时如何通过它来进行查找。

因此，在创建的过程中， a 和 b 的内部 [[Prototype]] 都会关联到 Foo.prototype 对象上。当 a 和 b 中无法打到 myName时，它会（通过委托，参见第6章）在 Foo.prototype对象上找到。


##### 回顾“构造函数”

之前讨论 .constructor 属性时我们说过，看起来 a.constructor === Foo 意味着 a 确实有一个指向 Foo 的 .constructor 属性，但是事实不是这样。

这是一个很不幸的误解。实际上， .constructor 引用同样被委托给了 Foo.prototype，而 Foo.prototype.constructor 默认指向 Foo。

把 .constructor 属性指向 Foo 看作是 a 对象由 Foo “构造”非常容易理解，但这只不过是一种虚设的安全感。 **a.constructor 只是通过默认的[[Prototype]]委托指向Foo**，这和“构造”毫无关系。相反，对于 .constructor的错误理解很容易对你自己产生误导。

举例来说， **Foo.prototype 的 .constructor 属性只是  Foo 函数在声明时的默认属性**。如果你创建了一个新对象并替换了函数默认的 .prototype 对象引用，那么新对象并不会自动获得 .constructor 属性。

思考下面的代码：

```
    function Foo(){

    }

    Foo.prototype = {

    }

    var a= new Foo();

    a.constructor === Foo; // false！
    a.constructor === Object; // true!
```

Object(..) 并沒有“构造” a ，对吧？看起来应该是 Foo()"构造"了它。大部分开发者都认为是Foo()执行了构造工作，但是问题在于，如果你认为“constructor”表示“由..构造”的话， a.constructor应该是Foo,但是它并不是Foo!

到底怎么回事？ a 并没有 .constructor 属性，所以它会委托[[Prototype]]链上的 Foo.prototype 对象。但是这个对象也没有 .construtor 属性（不过默认的 Foo.prototype有这个属性！），所以它会继续委托，这次会委托给委托链顶端的 Object.prototype 。 这个对象有 .constuctor 属性，指向内置的 Object(..)函数。

错误观点已被摧毁。

当然，你可以给 Foo.prototype 添加一个 .constructor 属性，不过这需要手动添加一个符合正常行为的不可枚举（参见第3章）属性。

举例来说：

```
    function Foo(){}

    Foo.prototype = {}

    Object.defineProperty(Foo.prototype, "constructor", {
        enumerable: false,
        writable: true,
        configurable: true,
        value: Foo
    })

```

修复 .constructor 需要很多手动操作。所有这些工作都源于把 "constructor" 错误地理解为 “由..构造”，这个误解的代价实在太高了。

**实际上，对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype引用**。“constructor” 和 "prototype"这两个词本身的含义可能适用也可能不适用。最好的办法是记住这一点 **constructor并不表示被构造**。

.constructor 并不是一个不可变属性。它是不可枚举（参见上面的代码）的，但是它的值是可写的（可以被修改）。此外，你可以给任意 [[Prototype]]链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值。

和[[Get]]算法查找 [[Prototype]]链的机制一样， .constructor 属性引用的目标可能和你想的完全不同。

现在你应该明白这个属性多个随意了吧？

结论？ 一些随意的对象属性引用，比如 a.constructor ，实际上是不被信任的，它们不一定会指向默认的函数引用。此外，很快我们就会看到，稍不留神 a.constructor 就可能会指向你意想不到的地方。

a.constructor 是一个非常不可靠并且不安全的引用。**通常来说要尽量避免使用这些引用**。




