## 编译器再度来袭

回顾： 

`引擎`会在解释JavaScript代码之前首先对其进行**`编译`**。

`词法作用域`的核心内容是：

**在`编译`阶段中的`词法分析`阶段，会`找到所有的声明`，并用合适的作用域将他们关联起来。**

--------------------------------------------------------------

### 1. 提升

因此，正确的思考思路是，**包括变量和函数在内的`所有声明`都会在任何代码被执行前首先被处理**！！！

当你看到 var a = 2;时，可能会认为这是一个声明。但 JavaScript实际上会将其看成两个声明： var a; 和 a = 2; 第一个`定义`声明是在`编译阶段`进行的。第二个`赋值`声明会被**留在原地**等待`执行阶段`。

```
	a = 2;
	
	var a;
	
	console.log(a);
```

上面代码的执行顺序相当于：

```
	var a; // 编译阶段 - 声明变量（或者叫定义变量）
	
	a = 2; // 执行阶段 - 赋值
	
	console.log(a);
```

----------------------------------------------------------------

```
	console.log(a);
	var a = 2;
```

同理，上面的代码执行顺序：

```
	var a;  // 编译阶段
	
	console.log(a); 
	
	a = 2; // 执行阶段 ---> 留在原地
```

因此，打个比方，这个过程就好像**变量和函数的声明** 从它们在代码出现的位置被**移动到了最上面**。这个过程叫作**提升**。

换句话说，先有蛋（声明）后有鸡（赋值）。

--------------------------------------------------------------

### 2. 只有声明本身会被提升

> 重点： **只有声明本身会被提升**，而赋值或其他运行逻辑会留在**原地**。如果提升改变了代码执行的顺序，会造成非常严重的破坏。

```
	foo();
	
	function foo() {
		console.log( a ); // undefined
		var a = 2;
	}
	
```

foo 函数的声明(这个例子还包括实际函数的隐含值)被提升了,因此第一行中的调用可以正常执行。

另外值得注意的是，**每个作用域**都会进行提升操作。尽管前面大部分的代码片段已经简化了（因为它们只包含全局作用域），而我们正在讨论的 foo(..)函数自身也会在内部对 var a 进行提升（显示并不是提升到了整个程序的最上方）。因此这段代码实际会被理解为下面的形式：

```
	function foo() {  // <--- 函数 foo 的声明提升到全局作用域的最上面
		var a;  // <--- 变量 a 的声明提升到所处作用域的最上面
		console.log(a);  
		a = 2;
	}
	
	foo();
```

### 3. 函数表达式不会被提升

```
	foo(); // TypeError!
	
	var foo = function bar() {
		//...
	};
```

变量标识符 foo 被提升并分配给所在作用域（在这是时全局作用域）, 此时 foo值为 undefined; 对于 undefined 的值进行foo()函数调用会导致非法操作异常，从而抛出 TypeError。

实际执行顺序如下：

```
	var foo;
	
	foo(); // TypeError!
	
	foo = function bar() {
		// ...
	}
```

同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：

```
	
	foo(); // TypeError!
	
	bar(); // ReferenceError!
	
	var foo = function bar() {
		// ...
	}

```

上面代码提升过后，实际可以理解为以下形式：

```
	var foo;
	
	foo(); // TypeError!
	
	bar(); // ReferenceError!
	
	foo = function() {
		var bar = ...self...
		// ...
	}

```

