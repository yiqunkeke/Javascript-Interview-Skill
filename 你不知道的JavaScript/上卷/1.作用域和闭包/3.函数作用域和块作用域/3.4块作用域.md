## 块作用域

### 1.函数作用域

尽管`函数作用域`是最常见的`作用域单元`，也是现行大多数JavaScript中最普遍的设计方法。

但其他类型的`作用域单元`也是存在的，并且通过使用其他类型的作用域单元甚至可以实现维护起来更加优秀、简洁的代码。

----------------------------------------------------------------------------------------------

### 2.块作用域

除了JavaScript外的很多编程语言都支持`块作用域`，因此其他语言的开发者对于相关的思维方式很熟悉，但对于JavaScript的开发者来说，这个概念很陌生。

```
	for(var i = 0; i < 10; i++) {
		cosnole.log(i);
	}
```

我们在for循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 **`i 会被绑定在外部作用域`(函数或全局)**中的事实。

----------------------------------------------------------------------------------------------

### 3.块作用域的用处

变量的声明应该**距离使用的地方越近越好**，并最大限度地**本地化**。

```
	var foo = true;
	
	if(foo) {
		var bar = foo * 2;
		bar = something(bar);
		console.log(bar);
	}
```

bar 变量仅在 if 声明的上下文中使用，因此如果能将它声明在 if 块内部会是一个很有意义的事情。

但是，**当使用 `var` 声明变量时，它写在`哪里`都是一样的，因为它们最终都会属于`外部作用域`。**

换句话说，**用var声明的变量，并不会被劫持在所处的块作用域中**。

上面这段代码是为了风格更易读而伪装出的形式上的块作用域，如果使用这种形式，要确保没在作用域其他地方意外地使用 bar 只能依靠自觉性。

块作用域是一个用来对之前的`最小授权`原则进行扩展的工具，将代码`从函数中隐藏`信息扩展为`在块中隐藏`信息。

----------------------------------------------------------------------------------------------

### 4.`函数作用域`的弊端 vs `块作用域`优势

再次考虑for循环例子：

```
	for(var i = 0; i < 10; i++) {
		cosnole.log(i);
	}
```

为什么要把一个只在 for 循环内部使用（至少是应该只在内部使用）的变量 i 污染到整个函数作用域中呢？

**函数作用域弊端**：

开发者要`检查`自己的代码，以避免在作用范围意外地使用（或复用）某些变量，如果在错误的地方使用变量将导致未知变量的异常。

**块作用域优势**：

变量 i 的块作用域（如果存在的话）将使得其只能在 for循环内部使用，如果在函数中其他地方使用会导致错误。这对保证变量`不会被混乱地复用`及`提升代码的可维护性`都有很大帮助。

-------------------------------------------------------------------------------------------

### 5. 很可惜，表面上看，JavaScript并没有块作用域的相关功能。除了以下 with、catch、let、const

-------------------------------------------------------------------------------------------

### 6. with - 用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。

-------------------------------------------------------------------------------------------

### 7. try/catch 中的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。

```
	try {
		undefined(); // 执行一个非法操作来强制制造一个异常
	}
	catch(err) {
		console.log(err); // 能够正常执行！捕获到一个TypeError: undefined is not a function
	}
	
	console.log(err);  // ReferenceError: err not found
```

正如你所看到的， err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。

> 尽管这个行为已经被标准化，并且被大部分标准JavaScript环境（除了老版本的IE浏览器）所支持，但是当同一个作用域中的两个或多个catch分句用同样的标识符声明错误变量时，很多静态检查工具还是会发出警告。实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部，但是静态检查工具还是会烦人地发出警告。

> 为了避免这个不必要的警告，很多开发者会将 catch 的参数命名为 err1、err2 等。也有开发者干脆关闭了静态检查工具对重复变量名的检查。

-------------------------------------------------------------------------------------------------------------

### 8. let

ES6 改变了现状，引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。

- **let 关键字可以将变量绑定到所在的任意作用域中（通常是{ .. }内部）**。

换句话说，**let 将其声明的变量隐式地劫持了所在的块作用域**。

```
	var foo = true;
	
	if(foo) {
		let bar = foo * 2;
		bar = something( bar );
		console.log(bar);
	}
	
	console.log(bar); // ReferenceError
```

用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过程中，如果没有密切关注哪些作用域中有绑定的变量，并且习惯性地移动这些块或者将其包含在其他块中，就会导致代码变得混乱。

为块作用域显式地创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。通常来讲，显式的代码优于隐式或一些精巧但不清晰的代码。显式的块作用域风格非常容易书写，并且和其他语言中块作用域的工作原理一致：

- **创建块**：

只要声明是有效的，在声明中的任意位置都可以**使用{ .. }** 括号来 **为 let 创建一个用于绑定的块**。

```
	var foo = true;
	
	if(foo) {
		{ // <--- 显式的块
			let bar = foo * 2;
			bar = something( bar );
			console.log(bar);
		}
	}
	
	console.log(bar); // ReferenceError
```

在这个例子中，我们在 if 声明`内部`显式地创建了一个块，如果需要对其进行重构，整个块都可以方便地移动而不会对外部 if 声明的位置和语义产生任何影响。

在第4章，我们会讨论提升，**提升是指`声明`会被视为存在于其所出现的作用域的整个范围内**

- **使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。**

```
	{
		console.log(bar); // ReferenceError
		let bar = 2;
	}
```

- **let 循环**

```
	for(let i = 0; i<10; i++) {
		console.log(i);
	}
	
	console.log(i); // ReferenceError
```

for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其**重新绑定**到了循环的每一个**迭代**中，**确保使用上一个循环迭代结束时的值**重新进行赋值。

下面通过另一种方式来说明每次**迭代**时进行**重新绑定**的行为：

```
	{
		let j;
		for(j = 0; j<10; j++) {
			let i = j; // 每个迭代重新绑定！
			console.log(i)
		}
	}
```

**每个迭代重新绑定** 非常有趣，我们将会在第5章讨论闭包时进行说明。

------------------------------------------------------------------------------------------------

### 9. const

除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。

```
	var foo = true;
	
	if(foo) {
		var a = 2;
		const b = 3;  // 包含在 if中的块作用域常量
		
		a = 3;  // 正常！
		b = 4;  // 错误！TypeError: Assignment to constant variable（Assignment 赋值）
	}
	
	console.log(a); // 3
	console.log(b); // 错误！ ReferenceError: b is not defined
```


















