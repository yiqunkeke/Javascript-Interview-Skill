## 隐藏内部实现

对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但是反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码`“隐藏”`起来了。(这里我理解成函数的`封装`)

这么做的实际结果就是，在这个代码片段的周围创建了一个`作用域气泡`。也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的`包装函数`的作用域中，而不是先前所在的作用域中。

换句话说，**`可以把变量和函数包裹在一个函数的作用域`**中，然后用这个作用域来“隐藏”它们。

----------------------------------------------------------

为什么“隐藏”变量和函数是一个有用的技术？

### 1.最小特权原则

>**`最小特权原则`**（也叫最小授权或最小暴露原则）： 
> 这个原则是指，在软件设计中，**应该最小限度地**暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。

这个原则可以延伸到如何选择用作用域来包含变量和函数。

如果所有变量和函数都在全局作用域中，当然可以在所有内部嵌套作用域中访问到它们。但这样会破坏前面提到的`最小特权原则`。因为可能会暴露过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。

```
	function doSomething(a) {
		b = a + doSomethingElse( a * 2);
		console.log(b * 3)
	}
	
	function doSomethingElse(a) {
		return a - 1
	}
	
	var b; 
	
	doSomething(2); // 15
```

在这个代码片段中，变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..)内部具体实现的私有内容。给予外部作用域对 b 和 doSomethingElse(..)的"`访问权限`"不仅没有必要，而且可能是`危险`的，因为它们可能被有意或无意地非预期的方式使用，从而导致超出了 doSomething(..)的适用条件。


更`合理`的设计是：将这些私有的具体内部`隐藏`在 doSomething(..)内部如下：

```
	function doSomething(a) {
		function doSomethingElse(a) {
			return a - 1
		}
		
		var b; 
		
		b = a + doSomethingElse( a * 2);
		console.log(b * 3)
	}
	
	doSomething(2); // 15
```

现在，b 和 doSomethingElse(..)都无法从外部被访问，而只能被 doSomething(..)所控制。`功能性`和`最终效果` 都没有受影响，但是设计上**`将具体内容私有化`**了，设计良好的软件都会依此进行实现。

-------------------------------------------------------------

### 2.规避冲突

“隐藏”作用域中的变量和函数所带来的另一个好处是：

`可以避免同名标识符之间的冲突`。

冲突会导致变量的值被意外`覆盖`。

```
	function foo() {
		function bar(a) {
			i = 3; //修改for循环所属作用域中的i
			console.log(a + i);
		}
		
		for(var i = 0; i < 10; i++) {
			bar( i * 2 ) // 糟糕，无限循环了！
		}
	}

```

bar(..)内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..)内部 for循环中的 i。在本例子中导致了无限循环。因为 i 被固定设置为 3，永远满足小于10这个条件。

解决方法 - 声明**`本地变量`** 或使用`作用域隐藏内部声明`

bar(..)内部的赋值操作需要声明一个`本地变量`来使用，采用任何名字都可以，var i = 3; 就可以满足这个需求。（同时会为 i 声明一个前面提到过的“**`遮蔽变量`**”）

或者是采用一个**`完全不同的标识符`**名称，比如 var j = 3；

上述两种方法都可以解决，但是软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，因此在这种情况下**`使用作用域`**来`隐藏内部声明`是唯一的最佳选择。

-------------------------------------------------------------

### 3.全局命名空间

变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的`命名空间`。所有需要暴露给外界的功能都会成为这个对象（`命名空间`）的属性，而不是将自己的标识符暴露在顶级的`词法作用域`中。

如下：

```
	var MyReallyCoolLibrary = {
		awesome: 'stuff',
		doSomething: function() {
			// ...
		},
		doSomethingElse: function() {
			// ...
		}
	}
```

----------------------------------------------------------

### 4.`模块管理`

另外一种避免冲突的方法和现代的`模块`机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过`依赖管理器`的机制将库的标识符`显示地导入`到另一个`特定的作用域`中。

显而易见，这些工具并没有违反词法作用域规则的"神奇"功能。它们只是利用作用域的规则`强制所有标识符都不能注入到共享作用域`中，而是保持在`私有、无冲突`的作用域中。这样可以有效规避掉所有的意外冲突。

因此，只要你愿意，即使不使用任何依赖管理工具也可以实现相同的功效。第5章介绍`模块模式`的详情内容。


















































































